
Really H-M builds a type-structure / graph - and can assign the same type to
different program Nodes.  Lattice is Complete, so all types "fit" in the same
lattice, but H-M is looking for types that "do not fit", e.g. passing a String
where an Integer is needed, or Applying an Integer.

Usefulness of H-M is to Lattice JOIN Unified Types - lifting Types.

Classic poster-child example:
map: { A[] {A->B} -> .... } // Map a Collection of A, and a Function A->B, returns a Collection of B.

map(String[], {String->int}) : int[] // Passed a set of Strings to parse, return a filled int-array
map(Person[], {Person->Employee}) : Employee[] // Same for Person->Employee

So same Map Lattice Merges all inputs & thus outputs:
map(Scalar[], {Scalar->Scalar}) : Scalar[]

And Type-equiv-classes lets us lift "Scalar[]" to either "int[]" or "Employee[]".

So i need a pt-by-pt logic to flow type-equivs (which is what H-M does), but on
my more complex setup.  Need memory contents (TypeObjs) to carry equivs, at the
TypeObj level.  Within a TypeObj, both TypeAry and TypeStruct can nested equivs.
Want enuf equivs to allow normal prims to work: so field offsets & names (for
loads & stores), prim math, array types, function calls.

Red Herring: Display looks like a complex fcn ptr, but actually its Just
Another Argument to a Call.  Carried with the fidx/code-ptr.

Red Herring: Split of pointer/alias# from Memory.  Need both at every point of
actual use (load/store).  Some places ptrs carry thru without memory, and
vice-versa.

So in my map example:
	map={ oary f ->
	 nary = [#oary]; // new array same size as old array
	 for() {
	   tmp:A = oary[i]; // Load from oary, type A
	   rez:B = f(tmp);  // {A->B}(A) -> B
	   nary[i] = B;     // nary:[]0/B ; partially typed as nil, partially as B
	 }
	 nary;
	}

So in
 { oary -> #oary }
 { oary -> oary[idx] }
 { oary -> oary[idx]=val }
Need to unify type for "oary:X" with "X==[]Y"; X is typed as an array of Y.
Need to unify type for "idx" with "int"
Need to unify type for "val" with "Y".
So in map call above:

  Toary==[]TA // Length call
  Tnary==[]TB // Array constructor; 0-or-TB
  Toary==[]TA // Load
  Ti==int     // Load index
  Tf==TC->TD  // function TC to TD
  TC==TA      // Arg to function
  Tnary==[]TB // Store
  Ti==int     // Store index
  TB==TD      // Store value

Toary==[]TA
Tnary==[]TB
Ti   ==int
Tf   =={(TA<<TC)->(TB<<TD)} == {TA -> TB}

More: type-equvs in Memory.  Asking for #oary, means looking up TypeAry inside TypeMem using alias#.
Implies: Need a TypeVar for Memory, which maps alias#s to TypeVars.
Memory-producing Types need a "TMem"...
No "primitive" TypeVars; instead just use Node._val Type.

Cannot put U-F types in my Types, because of immutability.
So a TVar per Node.

Call/CEpi.  HM.java makes a new TVar for the result, keeps the TVars for the
args, make a fcn, and unifies with the incoming fcn.  Only CEpi has the result.
So CEpi takes the Ret TTupN3, makes a TLamba from Call args (might as well have
Call make a TLambda), CEpi makes a TFun from the TLambda+TTupN (same as FunPtr)
and unifies with the Call incoming TFun.





 490: #[8]       3  [[ 423 ]]  #[8] #[8] -- V490
 480: #[9]       3  [[ 125 ]]  #[9] #[9] -- V480
 494: ~(~Ctrl    3  [[ 398  408 ]]  ~(~Ctrl,~Ctrl) ~(~Ctrl,~Ctrl) -- V494
 460: 3          3  [[ 502 ]]  3 3 -- V460
 502: New*17  ____ ____ ____  460  [[ 503  501 ]]  New[]0/obj (Ctrl,[3]0/obj,_1109*[17]use) -- V502
 452: #[6]       3  [[ 320 ]]  #[6] #[6] -- V452
 449: 7          3  [[ 450 ]]  7 7 -- V449
 441: #[5]       3  [[ 423 ]]  #[5] #[5] -- V441
 435: 5          3  [[ 439 ]]  5 5 -- V435
 489: ~use       3  [[   5    5    5    5 ]]  ~use ~use -- V489

 418: New*12  ____   15  433  [[ 419  420 ]]  New_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]} (Ctrl,_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},_555$) -- V418
 420: DProj2   418  [[ 433 ]]  DProj2 _555*[12]use -- V420
 419: MrgProj  418    9  [[   5  439 ]]  MrgProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]}] -- V419

 433: *noinli  432  420  [[ 418  439  473 ]]  {x -> (Ctrl, [1:use],all)} _582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}] -- V433{ V422[ mem:V424,,x:V431]-> V432[V422[ mem:V424,,x:V431],V424,V431] }

 439: Call       4  419  433  435  [[ 440  442  445  444 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]}],_582$,5,_81*[]use) -- V439
 444: DProj3   439  [[ 431 ]]  DProj3 5 -- V444
 445: CProj0   439  [[ 422 ]]  CProj0 Ctrl -- V445
 442: MProj1   439    5  [[ 424 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]}] -- V442

 440: CallEpi  439    5  432  [[ 446  447  448 ]]  CallEpi (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],nScalar) -- V440
 448: DProj2   440  [[ 450 ]]  DProj2 nScalar -- V448
 447: MProj1   440  [[ 503  450 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V447
 446: CProj0   440  [[ 450 ]]  CProj0 Ctrl -- V446

 450: Call     446  447  325  448  449  [[ 451  453  454  455  456 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],_482[_78 0,{&}=*_191{ ctl:Ctrl  mem: [1:use] ^:_78$ x:int64 y:int64 -> (Ctrl, [1:~use],int64)}],nScalar,7,_28*[0,ALL]use?) -- V450
 456: CProj0   450  [[ 319 ]]  CProj0 Ctrl -- V456
 455: DProj4   450  [[ 323 ]]  DProj4 7 -- V455
 454: DProj3   450  [[ 322 ]]  DProj3 nScalar -- V454
 453: MProj1   450    5  [[ 321 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V453

 451: CallEpi  450    5  324  [[ 457  458 ]]  CallEpi (Ctrl, [1:~use],int64) -- V451
 458: DProj2   451  [[ 486 ]]  DProj2 int64 -- V458
 457: CProj0   451  [[ 473 ]]  CProj0 Ctrl -- V457

 473: Call     457  503  433  501  [[ 474  491  492  493 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],_582$,_1109*[17]use,_1109$) -- V473
 493: CProj0   473  [[ 422 ]]  CProj0 Ctrl -- V493
 492: DProj3   473  [[ 431 ]]  DProj3 _1109*[17]use -- V492
 491: MProj1   473    5  [[ 424 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V491

 474: CallEpi  473    5  432  [[ 475  477 ]]  CallEpi (Ctrl, [1:~use],nScalar) -- V474
 477: DProj2   474  [[ 478 ]]  DProj2 nScalar -- V477
 475: CProj0   474  [[ 478 ]]  CProj0 Ctrl -- V475

 478: Call     475  503  129  477  [[ 479  481  482  483 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],_318[_78 0,{#}=*_242{ ctl:Ctrl  mem: [1:use] ^:_78$ ary:_60*[6][]Scalar/obj -> (Ctrl, [1:~use],int64)}],nScalar,_28*[0,ALL]use?) -- V478
 483: CProj0   478  [[ 124 ]]  CProj0 Ctrl -- V483
 482: DProj3   478  [[ 127 ]]  DProj3 nScalar -- V482
 481: MProj1   478    5  [[ 126 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V481

 479: CallEpi  478    5  128  [[ 484  485 ]]  CallEpi (Ctrl, [1:~use],all) -- V479
 485: DProj2   479  [[ 486 ]]  DProj2 all -- V485
 484: CProj0   479  [[ 421 ]]  CProj0 Ctrl -- V484

 486: New*16  ____    7  458  485  [[ 487  488 ]]  New_753(0, int64, int64) (Ctrl,_1138(0, int64, all),_733*[16]use) -- V486
 488: DProj2   486  [[ 421 ]]  DProj2 _733*[16]use -- V488
 487: MrgProj  486  503  [[   5  421 ]]  MrgProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},16:_1138(0, int64, all),17:[3]0/obj] -- V487

 421: Scope    484  487 ____  488 ____ ____ ____  [[]]  Scope all -- V421

============ noinline_id[46] ============
 422: noinlin ____  445  493  [[ 423  424  432  432  431 ]]  {x -> (Ctrl, [1:use],all)} Ctrl -- V422[ mem:V424,,x:V431]
 431: Parm:x   422  444  492  [[ 432 ]]  Parm:x nScalar -- V431
 424: Parm: m  422  442  491  [[ 432 ]]  Parm: mem  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V424
 423: Parm:rp  422  441  490  [[ 432 ]]  Parm:rpc #[5,8] -- V423

 432: Ret_noi  422  424  431  423  422  [[ 433  440  474 ]]  Ret_noinline_id[46] (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],nScalar) -- V432[V422[ mem:V424,,x:V431],V424,V431]
============ noinline_id[46] ============
