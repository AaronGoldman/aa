
Really H-M builds a type-structure / graph - and can assign the same type to
different program Nodes.  Lattice is Complete, so all types "fit" in the same
lattice, but H-M is looking for types that "do not fit", e.g. passing a String
where an Integer is needed, or Applying an Integer.

Usefulness of H-M is to Lattice JOIN Unified Types - lifting Types.

Classic poster-child example:
map: { A[] {A->B} -> .... } // Map a Collection of A, and a Function A->B, returns a Collection of B.

map(String[], {String->int}) : int[] // Passed a set of Strings to parse, return a filled int-array
map(Person[], {Person->Employee}) : Employee[] // Same for Person->Employee

So same Map Lattice Merges all inputs & thus outputs:
map(Scalar[], {Scalar->Scalar}) : Scalar[]

And Type-equiv-classes lets us lift "Scalar[]" to either "int[]" or "Employee[]".

So i need a pt-by-pt logic to flow type-equivs (which is what H-M does), but on
my more complex setup.  Need memory contents (TypeObjs) to carry equivs, at the
TypeObj level.  Within a TypeObj, both TypeAry and TypeStruct can nested equivs.
Want enuf equivs to allow normal prims to work: so field offsets & names (for
loads & stores), prim math, array types, function calls.

Red Herring: Display looks like a complex fcn ptr, but actually its Just
Another Argument to a Call.  Carried with the fidx/code-ptr.

Red Herring: Split of pointer/alias# from Memory.  Need both at every point of
actual use (load/store).  Some places ptrs carry thru without memory, and
vice-versa.

So in my map example:
	map={ oary f ->
	 nary = [#oary]; // new array same size as old array
	 for() {
	   tmp:A = oary[i]; // Load from oary, type A
	   rez:B = f(tmp);  // {A->B}(A) -> B
	   nary[i] = B;     // nary:[]0/B ; partially typed as nil, partially as B
	 }
	 nary;
	}

So in
 { oary -> #oary }
 { oary -> oary[idx] }
 { oary -> oary[idx]=val }
Need to unify type for "oary:X" with "X==[]Y"; X is typed as an array of Y.
Need to unify type for "idx" with "int"
Need to unify type for "val" with "Y".
So in map call above:

  Toary==[]TA // Length call
  Tnary==[]TB // Array constructor; 0-or-TB
  Toary==[]TA // Load
  Ti==int     // Load index
  Tf==TC->TD  // function TC to TD
  TC==TA      // Arg to function
  Tnary==[]TB // Store
  Ti==int     // Store index
  TB==TD      // Store value

Toary==[]TA
Tnary==[]TB
Ti   ==int
Tf   =={(TA<<TC)->(TB<<TD)} == {TA -> TB}

More: type-equvs in Memory.  Asking for #oary, means looking up TypeAry inside TypeMem using alias#.
Implies: Need a TypeVar for Memory, which maps alias#s to TypeVars.
Memory-producing Types need a "TMem"...
No "primitive" TypeVars; instead just use Node._val Type.

Cannot put U-F types in my Types, because of immutability.
So a TVar per Node.

Call/CEpi.  HM.java makes a new TVar for the result, keeps the TVars for the
args, make a fcn, and unifies with the incoming fcn.  Only CEpi has the result.
So CEpi takes the Ret TTupN3, makes a TLamba from Call args (might as well have
Call make a TLambda), CEpi makes a TFun from the TLambda+TTupN (same as FunPtr)
and unifies with the Call incoming TFun.

BUG: Call makes a TLambda from inputs directly, but the Display needs to split
from the code-pointer.
439: Call: [ctl:4, mem:434, fcnptr:433, "5"] <<-- but display is "420"!
And need to "fresh" versions, but lazily.  H-M has ordering, gets the final
"shape" of a Lambda done before ANY uses.

Theory: instead of Unify an Apply/Call with the fresh version of a completed
Lambda/FunPtr type, i can unify across a Call boundary lazily & on-demand.
Can do this in H-M?
  Make a pass, skipping fcn ID unification, then at Call, no unification
  between return & arg BECAUSE fcn is NOT unified between return & arg.
  Then do fcn ID.
  
  Then make a pass, at every Call walk the structure of function, force
  unification of matching args.  Walk Function Return HMType - which is
  structural on HMOper and leaves on HMVar (and Find at every step).  If see an
  HMOper, expect same HMOper from Call Return, recursively.  At any Leaf,
  Unify with same Leaf from Func Return.  Goal: prove it in HM first.
  Goal: make a worklist version of HM with identical results (but perhaps
  not provably identical!)





AST:            Let "noinline_x"
           Lambda "i"         Apply2
          "i"        ("pair"  Apply2             Apply1)
                        ("&"  Apply1  "7")    ("#" Apply1)
                        ("noinline" "5")   ("noinline" "[3]")


 490: #[8]       3  [[ 423 ]]  #[8] #[8] -- V490
 480: #[9]       3  [[ 125 ]]  #[9] #[9] -- V480
 494: ~(~Ctrl    3  [[ 398  408 ]]  ~(~Ctrl,~Ctrl) ~(~Ctrl,~Ctrl) -- V494
 460: 3          3  [[ 502 ]]  3 3 -- V460
 502: New*17  ____ ____ ____  460  [[ 503  501 ]]  New[]0/obj (Ctrl,[3]0/obj,_1109*[17]use) -- V502
 452: #[6]       3  [[ 320 ]]  #[6] #[6] -- V452
 449: 7          3  [[ 450 ]]  7 7 -- V449
 441: #[5]       3  [[ 423 ]]  #[5] #[5] -- V441
 435: 5          3  [[ 439 ]]  5 5 -- V435
 489: ~use       3  [[   5    5    5    5 ]]  ~use ~use -- V489

 418: New*12  ____   15  433  [[ 419  420 ]]  New_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]} (Ctrl,_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},_555$) -- V418
 420: DProj2   418  [[ 433 ]]  DProj2 _555*[12]use -- V420
 419: MrgProj  418    9  [[   5  439 ]]  MrgProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]}] -- V419

 433: *noinli  432  420  [[ 418  439  473 ]]  {x -> (Ctrl, [1:use],all)} _582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}] -- V433{ [ ctl:V4, mem:V419,,x:V435]-> [V4,V419,V435] }
// Prior to removing dead display:
  { [ ctl:V422, mem:V424,^:V426,x:V431]-> [V422,V428,V431] }
// Prior to 1st Call unification  
  { [ ctl:V422, mem:V424,^:V426,x:V431]-> [V422,V428,V431] }
// After 1st Call unification
  { [V422>>V4,V424,V426>>V2>>V433>>...recursive death,V431>>V435]] -> [V422>>V4, V428, V431>>V435] }

  { [ ctl:V4, mem:V419,,x:V435]-> [ctl:V4,mem:V419,V435] }

// Need a "fresh" version of of V433.
 439: Call       4  419  433  435  [[ 440  442  445  444 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]}],_582$,5,_81*[]use) -- [ ctl:V4, mem:V419,^:V433{ [ ctl:V4, mem:V419,,x:V435]-> [V4,V419,V435] },x:V435]
 444: DProj3   439  [[ 431 ]]  DProj3 5 -- V444
 445: CProj0   439  [[ 422 ]]  CProj0 Ctrl -- V445
 442: MProj1   439    5  [[ 424 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]}] -- V442

 440: CallEpi  439    5  432  [[ 446  447  448 ]]  CallEpi (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],nScalar) -- [V4,V419,V435]
 448: DProj2   440  [[ 450 ]]  DProj2 nScalar -- V448
 447: MProj1   440  [[ 503  450 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V447
 446: CProj0   440  [[ 450 ]]  CProj0 Ctrl -- V446

 450: Call     446  447  325  448  449  [[ 451  453  454  455  456 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],_482[_78 0,{&}=*_191{ ctl:Ctrl  mem: [1:use] ^:_78$ x:int64 y:int64 -> (Ctrl, [1:~use],int64)}],nScalar,7,_28*[0,ALL]use?) -- [ ctl:V319, mem:V321,,x:V322,y:V323]
 456: CProj0   450  [[ 319 ]]  CProj0 Ctrl -- V456
 455: DProj4   450  [[ 323 ]]  DProj4 7 -- V455
 454: DProj3   450  [[ 322 ]]  DProj3 nScalar -- V454
 453: MProj1   450    5  [[ 321 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V453

 451: CallEpi  450    5  324  [[ 457  458 ]]  CallEpi (Ctrl, [1:~use],int64) -- [V319,V321,V41]
 458: DProj2   451  [[ 486 ]]  DProj2 int64 -- V458
 457: CProj0   451  [[ 473 ]]  CProj0 Ctrl -- V457

 473: Call     457  503  433  501  [[ 474  491  492  493 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],_582$,_1109*[17]use,_1109$) -- [ ctl:V457, mem:V503,^:V433{ [ ctl:V4, mem:V419,,x:V435]-> [V4,V419,V435] },x:V501]
 493: CProj0   473  [[ 422 ]]  CProj0 Ctrl -- V493
 492: DProj3   473  [[ 431 ]]  DProj3 _1109*[17]use -- V492
 491: MProj1   473    5  [[ 424 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V491

 474: CallEpi  473    5  432  [[ 475  477 ]]  CallEpi (Ctrl, [1:~use],nScalar) -- V474
 477: DProj2   474  [[ 478 ]]  DProj2 nScalar -- V477
 475: CProj0   474  [[ 478 ]]  CProj0 Ctrl -- V475

 478: Call     475  503  129  477  [[ 479  481  482  483 ]]  Call (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],_318[_78 0,{#}=*_242{ ctl:Ctrl  mem: [1:use] ^:_78$ ary:_60*[6][]Scalar/obj -> (Ctrl, [1:~use],int64)}],nScalar,_28*[0,ALL]use?) -- [ ctl:V124, mem:V126,,ary:V127]
 483: CProj0   478  [[ 124 ]]  CProj0 Ctrl -- V483
 482: DProj3   478  [[ 127 ]]  DProj3 nScalar -- V482
 481: MProj1   478    5  [[ 126 ]]  MProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V481

 479: CallEpi  478    5  128  [[ 484  485 ]]  CallEpi (Ctrl, [1:~use],all) -- [V124,V126,V54]
 485: DProj2   479  [[ 486 ]]  DProj2 all -- V485
 484: CProj0   479  [[ 421 ]]  CProj0 Ctrl -- V484

 486: New*16  ____    7  458  485  [[ 487  488 ]]  New_753(0, int64, int64) (Ctrl,_1138(0, int64, all),_733*[16]use) -- V486
 488: DProj2   486  [[ 421 ]]  DProj2 _733*[16]use -- V488
 487: MrgProj  486  503  [[   5  421 ]]  MrgProj1  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},16:_1138(0, int64, all),17:[3]0/obj] -- V487

 421: Scope    484  487 ____  488 ____ ____ ____  [[]]  Scope all -- V421

============ noinline_id[46] ============
 422: noinlin ____  445  493  [[ 423  424  432  432  431 ]]  {x -> (Ctrl, [1:use],all)} Ctrl -- V4
 431: Parm:x   422  444  492  [[ 432 ]]  Parm:x nScalar -- V435
 424: Parm: m  422  442  491  [[ 432 ]]  Parm: mem  [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj] -- V419
 423: Parm:rp  422  441  490  [[ 432 ]]  Parm:rpc #[5,8] -- V423

 432: Ret_noi  422  424  431  423  422  [[ 433  440  474 ]]  Ret_noinline_id[46] (Ctrl, [1:~use,7:_1051@{LOW_PRIMS},12:_798@{^=_181*[7]use; noinline_id=_582[_555*[12]use,noinline_id=*_613{ ctl:Ctrl  mem: [ mem ] ^:_555$ x -> (Ctrl, [1:use],all)}]},17:[3]0/obj],nScalar) -- [V4,V419,V435]
============ noinline_id[46] ============
