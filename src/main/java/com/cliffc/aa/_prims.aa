// aa source to define the primitives.  Unlike normal aa, this code allows
// $$JavaClassName; the Java class function "clazz_node" returns a Node.
// Typically used in the call position, with a FunPtrNode returned.

// ============================================================================
// Parse automatically uses this type and constructor when parsing integers
int = : @{
  _val : $#TypeInt$INT64;       // The Payload

  // Unary ops
  -_ = { -> int($$PrimNode$MinusI64(_val)) };
  !_ = { -> int($$PrimNode$Not(_val)) };
  
  // Simple integer math
  _+_  = { y:int -> int($$PrimNode$AddI64(_val,y._val)) };
  _-_  = { y:int -> int($$PrimNode$SubI64(_val,y._val)) };
  _*_  = { y:int -> int($$PrimNode$MulI64(_val,y._val)) };
  _/_  = { y:int -> int($$PrimNode$DivI64(_val,y._val)) };
  _%_  = { y:int -> int($$PrimNode$ModI64(_val,y._val)) };
  // Bitwise ops
  _&_  = { y:int -> int($$PrimNode$AndI64(_val,y._val)) };
  _|_  = { y:int -> int($$PrimNode$OrI64 (_val,y._val)) };
  

  // Int-vs-Float
  _+_  = { y:flt -> flt($$PrimNode$AddF64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _-_  = { y:flt -> flt($$PrimNode$SubF64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _*_  = { y:flt -> flt($$PrimNode$MulF64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _/_  = { y:flt -> flt($$PrimNode$DivF64($$PrimNode$ConvertI64F64(_val),y._val)) };

  // Integer relations
  _<_  = { y:int -> int($$PrimNode$LT_I64(_val,y._val)) };
  _<=_ = { y:int -> int($$PrimNode$LE_I64(_val,y._val)) };
  _>_  = { y:int -> int($$PrimNode$GT_I64(_val,y._val)) };
  _>=_ = { y:int -> int($$PrimNode$GE_I64(_val,y._val)) };
  _==_ = { y:int -> int($$PrimNode$EQ_I64(_val,y._val)) };
  _!=_ = { y:int -> int($$PrimNode$NE_I64(_val,y._val)) };

  // Int-vs-Float
  _<_  = { y:flt -> int($$PrimNode$LT_F64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _<=_ = { y:flt -> int($$PrimNode$LE_F64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _>_  = { y:flt -> int($$PrimNode$GT_F64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _>=_ = { y:flt -> int($$PrimNode$GE_F64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _==_ = { y:flt -> int($$PrimNode$EQ_F64($$PrimNode$ConvertI64F64(_val),y._val)) };
  _!=_ = { y:flt -> int($$PrimNode$NE_F64($$PrimNode$ConvertI64F64(_val),y._val)) };

// TODO: Some way in the parser to specify RHS should be thunked.
//_&&_ = { thunk:lazy -> _val ? thunk() : _val }
//_||_ = { thunk:lazy -> _val ? _val : thunk() }

  // Conversions.  Got a problem using "1.flt()" because this overloads 'flt'
  // as a type and a instance function.  
  str = { -> $$NewStrNode$ConvertI64Str(_val) };
  
};

// ============================================================================
// Parse automatically uses this type and constructor when parsing floats
flt = : @{
  _val : $#TypeFlt$FLT64;       // The Payload

  // Simple float math
  _+_  = { y:flt -> flt($$PrimNode$AddF64(_val,y._val)) };
  _-_  = { y:flt -> flt($$PrimNode$SubF64(_val,y._val)) };
  _*_  = { y:flt -> flt($$PrimNode$MulF64(_val,y._val)) };
  _/_  = { y:flt -> flt($$PrimNode$DivF64(_val,y._val)) };
  
  _+_  = { y:int -> flt($$PrimNode$AddF64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _-_  = { y:int -> flt($$PrimNode$SubF64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _*_  = { y:int -> flt($$PrimNode$MulF64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _/_  = { y:int -> flt($$PrimNode$DivF64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  
  // Float relations
  _<_  = { y:flt -> int($$PrimNode$LT_F64(_val,y._val)) };
  _<=_ = { y:flt -> int($$PrimNode$LE_F64(_val,y._val)) };
  _>_  = { y:flt -> int($$PrimNode$GT_F64(_val,y._val)) };
  _>=_ = { y:flt -> int($$PrimNode$GE_F64(_val,y._val)) };
  _==_ = { y:flt -> int($$PrimNode$EQ_F64(_val,y._val)) };
  _!=_ = { y:flt -> int($$PrimNode$NE_F64(_val,y._val)) };

  // Float vs int
  _<_  = { y:int -> int($$PrimNode$LT_F64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _<=_ = { y:int -> int($$PrimNode$LE_F64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _>_  = { y:int -> int($$PrimNode$GT_F64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _>=_ = { y:int -> int($$PrimNode$GE_F64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _==_ = { y:int -> int($$PrimNode$EQ_F64(_val,$$PrimNode$ConvertI64F64(y._val))) };
  _!=_ = { y:int -> int($$PrimNode$NE_F64(_val,$$PrimNode$ConvertI64F64(y._val))) };

  // Conversions.  Got a problem using "1.flt()" because this overloads 'flt'
  // as a type and a instance function.  
  str = { -> $$NewStrNode$ConvertF64Str(_val) };
};

// ============================================================================
// Parse automatically uses this type and constructor when parsing all top
// level reference types.

// OBSERVE: I am blending (on purpose) normal stack-frames ala nested functions
// & 1st-class functions with the normal Java-like class heirarchy.

// EXECUTION MODEL: When entering a normal function scope, I push a 'display' of
// the local frame on the stack.  When making an instance-call, I push the local
// instance as a frame on the stack, then the local function frame.  Returns
// have to unwind this.

// THINK: Binding the 1st arg is optional, according to context.

//   -- pers.billable( proj ) is: "pers is a record with field billable" and
//      "billable(pers,proj)" is a function and this is a 2-arg call, AND uses
//      the instance-method syntax.
//      Example with ints: 1._+_(2)
//   -- pers.billable is: "pers is a record with field billable"; the field is
//      loaded but no binding happens.  Since all final function fields are
//      pre-bound, this loads a bound (curried on this) function.
//      Example: 1._+_ is a 1-arg function which increments.
//   -- pers = Person() is "pers is a new record of Person; all final function
//      fields are pre-bound so 'this' is arg 0.
//      Example: 1 has a _+_ final field pre-bound to '1' on arg 0.
//   -- Person.billable is "an unbound function, arg 0 must be a Person"
//      Example with ints: int._+_
//   -- fcn= Person.billable; fcn(pers) is "bind the first arg of fcn to pers".
//      Example with ints: int._+_(1)
//   -- fcn= Person.billable; fcn(pers)(proj) is "bind the first arg of fcn to pers
//      and then call again with argument proj.
//      Example with ints: int._+_(1)(2)
//   -- fcn= Person.billable; fcn(pers,proj) is "call 2 arg fcn with pers and proj"
//      Example with ints: int._+_(1,2)

// THINK: 'LoadNode' semantics does a plain field lookup.  If the address is a
// value type, LoadNode does the "delayed binding of self" so that the ValNode
// constructor does NOT have to produce a type where all final function fields
// are pre-bound.

// New behavior: TFPs carry a full signature, especially args and their orders.
// New behavior: TFPs indicate which args are *curried*, and the display arg
// is curried (or not) according to how the TFP is obtained.  TFPs at call sites
// remain strongly typed on nargs, and on the display is curried-or-not.  

// New behavior: all type-level ref-types get " ref:" (hidden name) as a base type name.
// TODO: move "ref:" into Java code.  make "ref" an aa Type, with a no-arg constructor.

// New behavior: ref types are forced a no-arg constructor.

// New behavior: sweep the type-constructor body, for defs with the same
// type-name and are final-functions.  Promote them as new constructors.

// New behavior: structs+arrays: structs allow a special " ary" field which is
// an infinite collection of some homogenous scalar, has to have a " len"
// field, subtyped TypeInt, to hold the length.  Both appear or not together;
// missing counts as zero-length.  Drop TypeAry and TypeStr.  TypeObj is only
// subtyped by TypeStruct.

// Could also allow fixed-sized internal arrays, indexed by ary name and
// offset.  Value types as fixed-arrays can do this.



//ref := : @{
//  // no hash, no eq, no locking calls in base ref
//  _==_ = { y:ref -> int($$PrimNode$EQ_OOP(_val,y._val)) };
//  _!=_ = { y:ref -> int($$PrimNode$NE_OOP(_val,y._val)) };
//};


// ============================================================================
// Math
math = @{
  pi = $$ConNode$PI;
  rand = { x:int -> int($$PrimNode$RandI64(x._val)) };
};

// end of file
